// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using Microsoft.Protocols.TestTools.StackSdk.Security.Cryptographic;
using Microsoft.Protocols.TestTools.StackSdk.Asn1;

namespace Microsoft.Protocols.TestTools.StackSdk.Security.KerberosLib
{
    /// <summary>
    /// Base class of KileClientContext and KileServerContext
    /// Maintain the important parameters during Kerberos transport.
    /// </summary>
    public class KerberosContext
    {
        #region Members
        /// <summary>
        /// The current time on the client's host. Created by AP request.
        /// </summary>
        protected KerberosTime apRequestCtime;

        /// <summary>
        /// The microsecond part of the client's timestamp. Created by AP request.
        /// </summary>
        protected Microseconds apRequestCusec;

        /// <summary>
        /// Current remote sequence number
        /// While act as client, this represents server's.
        /// While act as server, this represents client's.
        /// </summary>
        protected internal uint currentRemoteSequenceNumber;

        /// <summary>
        /// Current local sequence number
        /// </summary>
        protected internal uint currentLocalSequenceNumber;

        #endregion

        #region Const Context
        /// <summary>
        /// The connection type, TCP or UDP.
        /// </summary>
        public TransportType TransportType
        {
            get;
            set;
        }

        /// <summary>
        /// Kerberos version
        /// </summary>
        public long Pvno
        {
            get;
            set;
        }

        /// <summary>
        /// Client supported encryption types
        /// </summary>
        public Asn1SequenceOf<KerbInt32> SupportedEType
        {
            get;
            set;
        }

        /// <summary>
        /// Host addresses
        /// </summary>
        public HostAddresses Addresses
        {
            get;
            set;
        }

        /// <summary>
        /// Whether the sender is the security context initiator.
        /// </summary>
        public bool IsInitiator
        {
            get; private set;
        }
        #endregion

        #region Common Context
        /// <summary>
        /// Nonce
        /// </summary>
        public KerbUInt32 Nonce
        {
            get;
            set;
        }

        /// <summary>
        /// Encryption type selected by client and used in all message exchange
        /// </summary>
        public EncryptionType SelectedEType
        {
            get;
            set;
        }

        /// <summary>
        /// The domain name which the user belongs to
        /// </summary>
        public Realm Realm
        {
            get;
            set;
        }
        
        /// <summary>
        /// Princial of client
        /// </summary>
        public Principal CName
        {
            get;
            set;
        }

        /// <summary>
        /// Reply key of message exchange, initial reply key is principal long term key
        /// </summary>
        public EncryptionKey ReplyKey
        {
            get;
            set;
        }

        /// <summary>
        /// TGS ticket received from response
        /// </summary>
        public KerberosTicket Ticket
        {
            get;
            set;
        }

        /// <summary>
        /// TGS Session Key received from AS response
        /// </summary>
        public EncryptionKey SessionKey
        {
            get;
            set;
        }

        public EncryptionKey TgsSessionKey
        {
            get;set;
        }

        /// <summary>
        /// Subkey, generated by client
        /// </summary>
        public EncryptionKey Subkey
        {
            get;
            set;
        }

        /// <summary>
        /// AP Session Key received from TGS Response
        /// </summary>
        public EncryptionKey ApSessionKey
        { 
            get; set; 
        }

        /// <summary>
        /// The sub key returned by AP response.
        /// </summary>
        public EncryptionKey AcceptorSubKey
        { 
            get; set; 
        }

        /// <summary>
        /// The sub key created by AP request.
        /// </summary>
        public EncryptionKey ApSubKey
        {
            get;set;
        }

        /// <summary>
        /// The key currently used.
        /// </summary>
        public EncryptionKey ContextKey
        {
            get
            {
                return AcceptorSubKey ?? ApSubKey ?? ApSessionKey;
            }
        }

        /// <summary>
        /// Checksum flags
        /// </summary>
        public ChecksumFlags ChecksumFlag
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Current remote sequence number
        /// While act as client, this represents server's.
        /// While act as server, this represents client's.
        /// </summary>
        public uint CurrentRemoteSequenceNumber
        {
            get
            {
                if ((ChecksumFlag & ChecksumFlags.GSS_C_SEQUENCE_FLAG) == ChecksumFlags.GSS_C_SEQUENCE_FLAG)
                {
                    return currentRemoteSequenceNumber;
                }
                else
                {
                    return 0;
                }
            }
            set
            {
                currentRemoteSequenceNumber = value;
            }
        }

        /// <summary>
        /// The local message sequence number
        /// </summary>
        public uint CurrentLocalSequenceNumber
        {
            get { return currentLocalSequenceNumber; }
            set { this.currentLocalSequenceNumber = value; }
        }

        /// <summary>
        /// Get from AP request
        /// </summary>
        public KerberosTime Time
        {
            get
            {
                return apRequestCtime;
            }
            set
            {
                apRequestCtime = value;
            }
        }

        /// <summary>
        /// Get from AP request
        /// </summary>
        public Microseconds Cusec
        {
            get
            {
                return apRequestCusec;
            }
            set
            {
                this.apRequestCusec = value;
            }
        }
        #endregion

        #region FAST Context
        /// <summary>
        /// TGS ticket used in FAST
        /// </summary>
        public KerberosTicket ArmorTicket
        {
            get;
            set;
        }

        /// <summary>
        /// Session key for the Armor Ticket.
        /// </summary>
        public EncryptionKey ArmorSessionKey
        {
            get;
            set;
        }

        /// <summary>
        /// Fast armor key, made by subkey and tgs session key
        /// </summary>
        public EncryptionKey FastArmorkey
        {
            get;
            set;
        }
        #endregion

        #region Constructor
        /// <summary>
        /// Create context
        /// </summary>
        public KerberosContext(KerberosContextType contextType)
        {
            Pvno = KerberosConstValue.KERBEROSV5;
            IsInitiator = contextType.Equals(KerberosContextType.Client);
        }

        /// <summary>
        /// Create context
        /// </summary>
        /// <param name="domain">Domain name</param>
        /// <param name="cName">Principal name</param>
        /// <param name="password">Password of principal</param>
        /// <param name="accountType">Accoundtype, user or device</param>
        public KerberosContext(string domain, string cName, string password, KerberosAccountType accountType, KerberosContextType contextType, string salt = null)
            : this(contextType)
        {
            if (domain == null)
            {
                throw new ArgumentNullException("domain");
            }
            if (cName == null)
            {
                throw new ArgumentNullException("cName");
            }
            if (password == null)
            {
                throw new ArgumentNullException("password");
            }

            this.Realm = new Realm(domain);
            PrincipalName name = new PrincipalName(new KerbInt32((int)PrincipalType.NT_PRINCIPAL), KerberosUtility.String2SeqKerbString(cName));
            if (null == salt)
            {
                if (accountType == KerberosAccountType.User)
                    salt = KerberosUtility.GenerateSalt(domain, cName, accountType);

                else if (accountType == KerberosAccountType.Device)
                    salt = KerberosUtility.GenerateSalt(domain, cName, accountType);

                else
                {
                    throw new ArgumentOutOfRangeException("Account type not support");
                }
            }
            
            this.CName = new Principal(accountType, this.Realm, name, password, salt);
        }

        /// <summary>
        /// Create context
        /// </summary>
        /// <param name="domain">Domain name</param>
        /// <param name="cName">Principal name</param>
        /// <param name="password">Password of principal</param>
        /// <param name="accountType">Accoundtype, user or device</param>
        /// <param name="armorTicket">Computer TGT as armor ticket</param>
        /// <param name="armorSessionKey">Computer TGS session key as armor session key</param>
        public KerberosContext(string domain, string cName, string password, KerberosAccountType accountType, string salt, KerberosTicket armorTicket, EncryptionKey armorSessionKey, KerberosContextType contextType)
            : this(domain, cName, password, accountType, contextType, salt)
        {
            this.ArmorTicket = armorTicket;
            this.ArmorSessionKey = armorSessionKey;
            this.SelectedEType = (EncryptionType)this.ArmorTicket.SessionKey.keytype.Value;
        }
        #endregion

        /// <summary>
        /// Increase currentLocalSequenceNumber by 1.
        /// </summary>
        internal void IncreaseLocalSequenceNumber()
        {
            currentLocalSequenceNumber++;
        }

        /// <summary>
        /// Increase currentRemoteSequenceNumber by 1.
        /// </summary>
        internal void IncreaseRemoteSequenceNumber()
        {
            if ((ChecksumFlag & ChecksumFlags.GSS_C_SEQUENCE_FLAG) == ChecksumFlags.GSS_C_SEQUENCE_FLAG)
            {
                currentRemoteSequenceNumber++;
            }
        }

        #region KDC Settings from ptfconfig file
        /// <summary>
        /// KDC Ip or computer name, default set to empty and use domain name as KDC address.
        /// </summary>
        public static string KDCComputerName { get; set; }

        /// <summary>
        /// KDC default port
        /// </summary>
        public static int KDCPort = 88;
        #endregion
    }
}