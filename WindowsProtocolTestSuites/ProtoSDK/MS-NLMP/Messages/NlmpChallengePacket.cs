// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using Microsoft.Protocols.TestTools.StackSdk;

namespace Microsoft.Protocols.TestTools.StackSdk.Security.Nlmp
{
    /// <summary>
    /// the challenge packet of nlmp
    /// </summary>
    public class NlmpChallengePacket : NlmpPacket
    {
        /// <summary>
        /// 2.2.1.2 CHALLENGE_MESSAGE The CHALLENGE_MESSAGE defines an NTLM challenge message that is sent from the 
        /// server to the client. The CHALLENGE_MESSAGE is used by the server to challenge the client to prove its 
        /// identity. For connection-oriented requests, the CHALLENGE_MESSAGE generated by the server is in response 
        /// to the NEGOTIATE_MESSAGE (section 2.2.1.1) from the client.
        /// </summary>
        private CHALLENGE_MESSAGE payload;

        /// <summary>
        /// 2.2.1.2 CHALLENGE_MESSAGE The CHALLENGE_MESSAGE defines an NTLM challenge message that is sent from the 
        /// server to the client. The CHALLENGE_MESSAGE is used by the server to challenge the client to prove its 
        /// identity. For connection-oriented requests, the CHALLENGE_MESSAGE generated by the server is in response 
        /// to the NEGOTIATE_MESSAGE (section 2.2.1.1) from the client.
        /// </summary>
        public CHALLENGE_MESSAGE Payload
        {
            get
            {
                return this.payload;
            }
            set
            {
                this.payload = value;
            }
        }


        /// <summary>
        /// the length of challenge message
        /// </summary>
        protected override int PayLoadLength
        {
            get
            {
                return NlmpUtility.CHALLENGE_MESSAGE_CONST_SIZE
                    + payload.TargetNameFields.Len
                    + payload.TargetInfoFields.Len;
            }
        }


        /// <summary>
        /// default empty constructor
        /// </summary>
        public NlmpChallengePacket()
        {
            this.header.MessageType = MessageType_Values.CHALLENGE;
        }


        /// <summary>
        /// copy constructor.
        /// </summary>
        public NlmpChallengePacket(
            NlmpChallengePacket stackPacket
            )
            : base(stackPacket)
        {
            this.payload = stackPacket.payload;

            if (stackPacket.payload.TargetName != null)
            {
                this.payload.TargetName =
                    new byte[stackPacket.payload.TargetName.Length];
                Array.Copy(
                    stackPacket.payload.TargetName,
                    this.payload.TargetName,
                    stackPacket.payload.TargetName.Length);
            }

            if (stackPacket.payload.TargetInfo != null)
            {
                this.payload.TargetInfo =
                    new byte[stackPacket.payload.TargetInfo.Length];
                Array.Copy(
                    stackPacket.payload.TargetInfo,
                    this.payload.TargetInfo,
                    stackPacket.payload.TargetInfo.Length);
            }
        }


        /// <summary>
        /// decode packet from bytes
        /// </summary>
        /// <param name="packetBytes">the bytes contain packet</param>
        public NlmpChallengePacket(
            byte[] packetBytes
            )
            : base(packetBytes)
        {
        }


        /// <summary>
        /// to create an instance of the StackPacket class that is identical to the current StackPacket. 
        /// </summary>
        /// <returns>return the clone of this packet</returns>
        public override StackPacket Clone()
        {
            return new NlmpChallengePacket(this);
        }


        /// <summary>
        /// write the payload to bytes.
        /// for all sub class to marshal itself.
        /// </summary>
        /// <returns>the bytes of struct</returns>
        protected override byte[] WriteStructToBytes()
        {
            byte[] bytes = NlmpUtility.StructGetBytes(payload);

            if (PayLoadLength != bytes.Length)
            {
                throw new InvalidOperationException("the payload length is not equal to the marshal size!");
            }

            return bytes;
        }


        /// <summary>
        /// read struct from bytes. All sub class override this to unmarshal itself.
        /// </summary>
        /// <param name="start">the start to read bytes</param>
        /// <param name="packetBytes">the bytes of struct</param>
        /// <returns>the read result, if success, return true.</returns>
        protected override bool ReadStructFromBytes(
            byte[] packetBytes, 
            int start
            )
        {
            CHALLENGE_MESSAGE challenge = new CHALLENGE_MESSAGE();

            challenge.TargetNameFields = NlmpUtility.BytesToStruct<MESSAGE_FIELDS>(packetBytes, ref start);
            challenge.NegotiateFlags = (NegotiateTypes)NlmpUtility.BytesToStruct<uint>(packetBytes, ref start);
            challenge.ServerChallenge = NlmpUtility.BytesToStruct<ulong>(packetBytes, ref start);
            challenge.Reserved = NlmpUtility.BytesToStruct<ulong>(packetBytes, ref start);
            challenge.TargetInfoFields = NlmpUtility.BytesToStruct<MESSAGE_FIELDS>(packetBytes, ref start);

            // Unmarshal the Version field.
            // The Version field is NOT sent or accessed by Windows NT or Windows 2000. Windows NT and Windows 2000
            // assume that the Payload field started immediately after WorkstationNameBufferOffset.
            if (challenge.TargetInfoFields.BufferOffset != start
                && challenge.TargetNameFields.BufferOffset != start)
            {
                challenge.Version = NlmpUtility.BytesToStruct<VERSION>(packetBytes, ref start);
            }

            int currentIndex = 0;
            while (currentIndex != start)
            {
                currentIndex = start;
                if (challenge.TargetNameFields.Len !=0 && challenge.TargetNameFields.BufferOffset == start)
                {
                    challenge.TargetName = NlmpUtility.ReadBytes(
                        packetBytes, ref start, challenge.TargetNameFields.Len);
                    continue;
                }
                else if (challenge.TargetInfoFields.Len != 0 && challenge.TargetInfoFields.BufferOffset == start)
                {
                    challenge.TargetInfo = NlmpUtility.ReadBytes(
                        packetBytes, ref start, challenge.TargetInfoFields.Len);
                    continue;
                }
                else
                {
                    break;
                }
            }

            this.payload = challenge;

            return true;
        }


        /// <summary>
        /// set the version
        /// </summary>
        /// <param name="version">the new version</param>
        public override void SetVersion(
            VERSION version
            )
        {
            payload.Version = version;
        }


        /// <summary>
        /// set the negotiate flags
        /// </summary>
        /// <param name="negotiateFlags">the new flags</param>
        public override void SetNegotiateFlags(
            NegotiateTypes negotiateFlags
            )
        {
            payload.NegotiateFlags = negotiateFlags;
        }


        /// <summary>
        /// set the serverChallenge of payload
        /// </summary>
        /// <param name="serverChallenge">the new serverChallenge</param>
        public void SetServerChallenge(
            ulong serverChallenge
            )
        {
            payload.ServerChallenge = serverChallenge;
        }


        /// <summary>
        /// set the target name of payload
        /// </summary>
        /// <param name="targetName">the new target name</param>
        public void SetTargetName(
            string targetName
            )
        {
            payload.TargetName = NlmpUtility.StringGetBytes(
                targetName, NlmpUtility.IsUnicode(this.payload.NegotiateFlags));

            payload.TargetNameFields.Len = (ushort)payload.TargetName.Length;

            payload.TargetNameFields.MaxLen = (ushort)payload.TargetName.Length;

            UpdateOffset();
        }


        /// <summary>
        /// set the target info of payload
        /// </summary>
        /// <param name="targetInfoBytes">the new target info</param>
        public void SetTargetInfo(
            byte[] targetInfoBytes
            )
        {
            if (targetInfoBytes == null || targetInfoBytes.Length == 0)
            {
                return;
            }

            payload.TargetInfoFields.Len = (ushort)targetInfoBytes.Length;
            payload.TargetInfoFields.MaxLen = (ushort)targetInfoBytes.Length;
            payload.TargetInfo = targetInfoBytes;

            UpdateOffset();
        }


        /// <summary>
        /// update the offset of payload
        /// </summary>
        private void UpdateOffset()
        {
            payload.TargetNameFields.BufferOffset = (uint)(HeaderLength + NlmpUtility.CHALLENGE_MESSAGE_CONST_SIZE);

            payload.TargetInfoFields.BufferOffset = (uint)(
                HeaderLength + NlmpUtility.CHALLENGE_MESSAGE_CONST_SIZE + payload.TargetNameFields.Len);
        }
    }
}
